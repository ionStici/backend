# Generating a JWT Token

```ts
// auth/providers/sign-in.provider.ts
import { Injectable, Inject } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";
import { ConfigType } from "@nestjs/config";
import jwtConfig from "../config/jwt.config";
import { SignInDto } from "../dtos/sign-in.dto";

@Injectable()
export class SignInProvider {
  constructor(
    @Inject(jwtConfig.KEY)
    private readonly jwtConfiguration: ConfigType<typeof jwtConfig>, // Injecting JWT configuration
    private readonly jwtService: JwtService // Injecting JwtService
  ) {}

  public async signIn(signInDto: SignInDto) {
    const user = await this.authenticateUser(signInDto);
    // ... rest of the signin logic

    // Generate the access token
    const accessToken = await this.jwtService.signAsync(
      {
        sub: user.id, // Subject of the token (usually user ID)
        email: user.email, // Additional information in the payload (email)
      },
      {
        audience: this.jwtConfiguration.audience, // JWT audience
        issuer: this.jwtConfiguration.issuer, // JWT issuer
        secret: this.jwtConfiguration.secret, // JWT secret
        expiresIn: this.jwtConfiguration.accessTokenTTL, // Token expiration time
      }
    );

    return {
      accessToken, // Return the token as part of the response
    };
  }
}
```

_Explanation:_

- `JwtService` : Built-in Service that helps generating and signing tokens.
- `jwtConfiguration` : Allows us to access the values stored in the `.env` file.
- The `signAsync` method of the `JwtService` is used to generate JWT tokens. This method takes 2 arguments: (1) Payload, and (2) Options.
- The generated JWT token is returned as a response to the user, which they can use for subsequent authenticated requests.

_Example Payload for JWT:_

- `sub` : Represents the subject (typically the user's ID)
- `email` : An optional payload containing the user's email.

_Example JWT Options:_

- `audience` : Specifies the intended audience for the token (e.g., the domain).
- `issuer` : Identifies the party that issued the token (e.g., your server).
- `secret` : The secret key used to sign the token (stored in environment variables).
- `expiresIn` : Time to Live (TTL) for the token (e.g., 3600 seconds = 1 hour).

## Understanding JWT

### Decoding JWT using JWT.io Debugger

Paste a JWT token into the JWT.io debugger to decode it:

1. **Header:** Contains metadata about the token, such as the algorithm used for signing.

2. **Payload:** Contains user-specific data like `sub` (user ID), `email`, `iat` (issued at), `exp` (expiration time), `aud` (audience), `iss` (issuer).

3. **Signature:** is generated by encoding the header and payload using a secret key that resides on the server. This signature ensures that the token has not been tampered with.

### Validating the JWT

JWT tokens are **not encrypted**, instead they are **signed**. How's how it works:

1. **Public Data:**

   - The **header** and **payload** of the token are **Base64 encoded** but not encrypted. This means anyone can decode and view the information by simply pasting the token into a tool like JWT.io
   - **Note:** Never store sensitive information such as passwords or credit cards details in the payload.

2. **Signature Validation:**

   - The **signature** ensures the integrity of the token. If any part of the token is altered (such as modifying the `exp` or `email`), the signature will no longer match the server's signature.
   - This mismatch makes the token **invalid**, and the server will reject it.

3. **Expiration Time (`exp`):**

   - The token has a limited **time to live** (TTL). After the time has expired, the token becomes invalid, and the user must log in again.

### Key Points

1. **Public vs. Private Data:**

   - JWT tokens are **public** (payload can be decoded). The key to security is the **signature**, which ensures the token hasn't been modified.

2. **Short Expiration Times:**

   - Tokens should have short expiration times to minimize security risks (e.g., 3600 seconds = 1 hour).
   - Once a token expires, the user needs to log in again to receive a new token.

3. **Refresh Tokens:**

   - To avoid users having to log in frequently, refresh tokens can be implemented. Refresh tokens allow the user to request a new access token without logging in again.

### Conclusion

- **JWT Token Structure:** JWT tokens have three partsâ€”header, payload, and signature. Only the signature ensures the token's authenticity.
- **Testing JWT Tokens:** We tested the token generation and validated it using JWT.io, showing how tampering with the token invalidates it.
- **Security:** Avoid putting sensitive data in the payload. Use short token expiration times for added security.
